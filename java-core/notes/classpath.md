---
description: Базовое использование classpath
---

# Classpath

Оригиналы статей: [раз](https://www.ibm.com/developerworks/ru/library/j-classpath-unix/)

### Введение

Classpath представляет собой связующее звено между исполняемым модулем Java и файловой системой. Он определяет, где интерпретатор ищет файлы класса для загрузки. Основная идея состоит в том, что иерархия файловой системы отражает иерархию пакета Java, а classpath определяет, какие директории в файловой системе служат корневыми каталогами для иерархии пакета Java. По существу classpath указывает компилятору или виртуальной машине где искать классы необходимые для сборки проекта или же его запуска

### Именование пакетов

После обратного имени домена используйте только имена подпакета, состоящие из одного слова. Не используйте сокращения и пишите все слова правильно.  Большой процент проблем, связанных с classpath, вызван использованием одного слова в исходной программе и слегка измененного написания или сокращения этого слова в файловой системе. Единственный разумный выбор - всегда использовать правильно написанные, несокращенные имена.

Полное имя пакета должно быть написано строчными буквами, даже для имен собственных и аббревиатур, которые обычно пишутся заглавными буквами. Имя пакета должно быть составлено только из ASCII-символов. Хотя компилятор принимает имена пакета, записанные на иврите, кириллице, греческом, и других шрифтах, многие файловые системы не принимают их. Как вы скоро увидите, эти имена пакетов будут выполнять двойную задачу в качестве имен директорий. Следовательно, имена пакетов \(и классов\) должны быть ограничены ASCII. \(В то время как в пакетах Java и именах классов используется юникод, многие файловые системы ещё его не понимают. Простое копирование файла в систему с другой кодировкой по умолчанию может помешать компилятору и интерпретатору найти правильные классы.\)

Не экономьте на имени вашего пакета! Это только приведет к катастрофе в конечном счете. Не располагайте ваши классы в пакете по умолчанию \(пакете, который вы получаете, если не включаете оператор пакета в класс\). Если доступ пакета мешает объектам посылать сообщения, добавьте больше общедоступных методов в классы. Каждый класс, который будет использоваться чаще, чем один раз, должен быть в пакете.

### Структура директорий

Следующий шаг - это организовать ваши исходные файлы так, чтобы они соответствовали структуре пакета.

Пример организации: 

```text
├── bin
├── src
    └── com
        └── ninja
            └── test

```

Очень важно: никогда не помещайте ничего, кроме исходного кода в вашу директорию src. Обычно единственные файлы, которые вы помещаете туда, это .java-файлы. Иногда вы можете расположить .html-файлы \(для Javadoc\) или другие типы исходного кода в эту директорию. Тем не менее, вы не должны помещать .class-файлы или другие скомпилированные, сгенерированные артефакты в эту иерархию. Выполнение этого действия непременно приведет к катастрофе. К сожалению, компилятор javac сделает именно так, если вы не проявите осторожность. В следующем разделе я покажу вам, как наладить это.

### Компилирование <a id="N100AF"></a>

Компилирование кода Java - коварная вещь, потому что вам нужно отслеживать несколько связанных, но разных вещей:

* Целевой файл, который вы компилируете.
* Директорию, где компилятор ищет .java-файлы, которые импортирует целевой файл.
* Директорию, где компилятор ищет .class-файлы, которые импортирует целевой файл.
* Директорию, куда компилятор помещает скомпилированный вывод.

По умолчанию, компилятор javac думает, что все это - текущая рабочая директория, что почти всегда не то, что вам нужно. Следовательно, при компиляции вы должны четко точно определить каждый из элементов.

#### Файл для компиляции <a id="N100C0"></a>

Первое, что вы определяете, - это .java-файл, который вы собираетесь компилировать. Это дается как путь к файлу из текущей рабочей директории. Например:  

```bash
 javac com/ninja/test/Main.java
```

#### Куда идет вывод <a id="N100EB"></a>

javac располагает скомпилированный .class-файл в той же директории, где находится .java файл. Переключатель `-d` точно определяет директорию вывода \(обычно называемую bin, build, или classes\):

```bash
 javac -d bin com/ninja/test/Main.java
```

Обратите внимание, что javac создал полную иерархию директорий. Это произойдет только в том случае если указать `package com.ninja.test`  в классе `Main.java` .

```text
├── bin
│   └── com
│       └── ninja
│           └── test
│               └── Main.class
└── src
    └── com
        └── ninja
            └── test
                └── Main.java
```

#### Путь к исходным файлам \(sourcepath\) <a id="N10108"></a>

Директория, где Java ищет исходные файлы называется _sourcepath_. В схеме, намеченной здесь, это `src` директория. Это директория, которая содержит _иерархию_ исходных файлов, организованных в их собственных директориях. Это _не_ директория `com` или `src/com/ninja/test`.

Большинство проектов используют больше, чем один класс и больше, чем один пакет. Они связаны импортирующими операторами и полностью подготовленными для пакета именами класса. Например, предположим, что вы сейчас создаете новый класс `Solution` в пакете `com.ninja.task`, как показано в листинге 1:

{% code-tabs %}
{% code-tabs-item title="Solution.java" %}
```java
package com.ninja.task;

import com.ninja.test.*;

public class Solution {
	public static void main(String[] args){
		Main main = new Main();
	}
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

 При вызове команды:

```text
javac -d bin src/com/ninja/task/Solution.java
```

Получается ошибка : 

```text
src/com/ninja/task/Solution.java:3: error: package com.ninja.test does not exist
import com.ninja.test.*; 
^ 
src/com/ninja/task/Solution.java:7: error: cannot find symbol
                Main main = new Main();
                 ^ 
   symbol: class Main
   location: class Solution 
src/com/ninja/task/Solution.java:7: error: cannot find symbol
                Main main = new Main(); 
                                                ^
    symbol: class Main
    location: class Solution
 3 errors
```



Ошибки произошли, потому что хотя javac знал, где найти Solution.java, он не знал, где найти Main.java. Необходимо указать _sourcepath_. Он указывает директории, где компилятор ищет иерархию исходных файлов. Это src. Итак, я использую опцию `-sourcepath`, например, так:

```bash
javac -d bin -sourcepath src src/com/ninja/task/Solution.java
```

Обратите внимание, что javac также скомпилировал файл Main.java, на который ссылается файл Solution.

#### Компилирование множественных директорий в sourcepath <a id="N10163"></a>

На самом деле вы можете иметь более одной директории в вашем sourcepath \(они разделяются двоеточиями\), хотя это обычно не нужно. 

Эта команда не компилирует каждый файл, найденный в какой-либо из этих иерархий. Она компилирует только файлы, на который делается ссылка прямо или косвенно одним .java-файлом, который я явно прошу скомпилировать.

Гораздо чаще у вас будет одна директория source для .java файлов, но много директорий для классов или JAR-архивов, где расположены прекомпилированные библиотеки сторонних производителей. Такова роль classpath.

#### Установка classpath <a id="N10171"></a>

В средних и больших проектах перекомпилирование каждого файла каждый раз может занимать очень много времени. Вы можете облегчить нагрузку, отдельно компилируя и храня независимые части одного и того же проекта в разных классах или директориях bin. Эти директории добавляются к classpath.

Есть несколько способов добавить класс к classpath. Переключатель командной строки `-classpath`, тем не менее, - единственное, что следует использовать. Например, предположим, что я хочу импортировать файлы из другого проекта, который я до этого скомпилировал в директорию /Users/elharo/classes. Затем я бы добавил `-classpath /Users/elharo/classes` к командной строке следующим образом:

