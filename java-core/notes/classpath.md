---
description: Базовое использование classpath
---

# Classpath

Оригиналы статей: [раз](https://www.ibm.com/developerworks/ru/library/j-classpath-unix/)

### Введение

Classpath представляет собой связующее звено между исполняемым модулем Java и файловой системой. Он определяет, где интерпретатор ищет файлы класса для загрузки. Основная идея состоит в том, что иерархия файловой системы отражает иерархию пакета Java, а classpath определяет, какие директории в файловой системе служат корневыми каталогами для иерархии пакета Java. По существу classpath указывает компилятору или виртуальной машине где искать классы необходимые для сборки проекта или же его запуска

### Именование пакетов

После обратного имени домена используйте только имена подпакета, состоящие из одного слова. Не используйте сокращения и пишите все слова правильно.  Большой процент проблем, связанных с classpath, вызван использованием одного слова в исходной программе и слегка измененного написания или сокращения этого слова в файловой системе. Единственный разумный выбор - всегда использовать правильно написанные, несокращенные имена.

Полное имя пакета должно быть написано строчными буквами, даже для имен собственных и аббревиатур, которые обычно пишутся заглавными буквами. Имя пакета должно быть составлено только из ASCII-символов. Хотя компилятор принимает имена пакета, записанные на иврите, кириллице, греческом, и других шрифтах, многие файловые системы не принимают их. Как вы скоро увидите, эти имена пакетов будут выполнять двойную задачу в качестве имен директорий. Следовательно, имена пакетов \(и классов\) должны быть ограничены ASCII. \(В то время как в пакетах Java и именах классов используется юникод, многие файловые системы ещё его не понимают. Простое копирование файла в систему с другой кодировкой по умолчанию может помешать компилятору и интерпретатору найти правильные классы.\)

Не экономьте на имени вашего пакета! Это только приведет к катастрофе в конечном счете. Не располагайте ваши классы в пакете по умолчанию \(пакете, который вы получаете, если не включаете оператор пакета в класс\). Если доступ пакета мешает объектам посылать сообщения, добавьте больше общедоступных методов в классы. Каждый класс, который будет использоваться чаще, чем один раз, должен быть в пакете.

### Структура директорий

Следующий шаг - это организовать ваши исходные файлы так, чтобы они соответствовали структуре пакета.

Пример организации: 

```text
├── bin
├── src
    └── com
        └── ninja
            └── test

```

Очень важно: никогда не помещайте ничего, кроме исходного кода в вашу директорию src. Обычно единственные файлы, которые вы помещаете туда, это .java-файлы. Иногда вы можете расположить .html-файлы \(для Javadoc\) или другие типы исходного кода в эту директорию. Тем не менее, вы не должны помещать .class-файлы или другие скомпилированные, сгенерированные артефакты в эту иерархию. Выполнение этого действия непременно приведет к катастрофе. К сожалению, компилятор javac сделает именно так, если вы не проявите осторожность. В следующем разделе я покажу вам, как наладить это.

### Компилирование <a id="N100AF"></a>

Компилирование кода Java - коварная вещь, потому что вам нужно отслеживать несколько связанных, но разных вещей:

* Целевой файл, который вы компилируете.
* Директорию, где компилятор ищет .java-файлы, которые импортирует целевой файл.
* Директорию, где компилятор ищет .class-файлы, которые импортирует целевой файл.
* Директорию, куда компилятор помещает скомпилированный вывод.

По умолчанию, компилятор javac думает, что все это - текущая рабочая директория, что почти всегда не то, что вам нужно. Следовательно, при компиляции вы должны четко точно определить каждый из элементов.

#### Файл для компиляции <a id="N100C0"></a>

Первое, что вы определяете, - это .java-файл, который вы собираетесь компилировать. Это дается как путь к файлу из текущей рабочей директории. Например:  

```bash
 javac com/ninja/test/Main.java
```

#### Куда идет вывод <a id="N100EB"></a>

javac располагает скомпилированный .class-файл в той же директории, где находится .java файл. Переключатель `-d` точно определяет директорию вывода \(обычно называемую bin, build, или classes\):

```bash
 javac -d bin com/ninja/test/Main.java
```

Обратите внимание, что javac создал полную иерархию директорий. Это произойдет только в том случае если указать `package com.ninja.test`  в классе `Main.java` .

```text
├── bin
│   └── com
│       └── ninja
│           └── test
│               └── Main.class
└── src
    └── com
        └── ninja
            └── test
                └── Main.java
```

#### Путь к исходным файлам \(sourcepath\) <a id="N10108"></a>

Директория, где Java ищет исходные файлы называется _sourcepath_. В схеме, намеченной здесь, это `src` директория. Это директория, которая содержит _иерархию_ исходных файлов, организованных в их собственных директориях. Это _не_ директория `com` или `src/com/ninja/test`.

Большинство проектов используют больше, чем один класс и больше, чем один пакет. Они связаны импортирующими операторами и полностью подготовленными для пакета именами класса. Например, предположим, что вы сейчас создаете новый класс `Solution` в пакете `com.ninja.task`, как показано в листинге 1:

{% code-tabs %}
{% code-tabs-item title="Solution.java" %}
```java
package com.ninja.task;

import com.ninja.test.*;

public class Solution {
	public static void main(String[] args){
		Main main = new Main();
	}
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

 При вызове команды:

```text
javac -d bin src/com/ninja/task/Solution.java
```

Получается ошибка : 

```text
src/com/ninja/task/Solution.java:3: error: package com.ninja.test does not exist
import com.ninja.test.*; 
^ 
src/com/ninja/task/Solution.java:7: error: cannot find symbol
                Main main = new Main();
                 ^ 
   symbol: class Main
   location: class Solution 
src/com/ninja/task/Solution.java:7: error: cannot find symbol
                Main main = new Main(); 
                                                ^
    symbol: class Main
    location: class Solution
 3 errors
```



Ошибки произошли, потому что хотя javac знал, где найти Solution.java, он не знал, где найти Main.java. Необходимо указать _sourcepath_. Он указывает директории, где компилятор ищет иерархию исходных файлов. Это src. Итак, я использую опцию `-sourcepath`, например, так:

```bash
javac -d bin -sourcepath src src/com/ninja/task/Solution.java
```

Обратите внимание, что javac также скомпилировал файл Main.java, на который ссылается файл Solution.

#### Компилирование множественных директорий в sourcepath <a id="N10163"></a>

На самом деле вы можете иметь более одной директории в вашем sourcepath \(они разделяются двоеточиями\), хотя это обычно не нужно. 

Эта команда не компилирует каждый файл, найденный в какой-либо из этих иерархий. Она компилирует только файлы, на который делается ссылка прямо или косвенно одним .java-файлом, который я явно прошу скомпилировать.

Гораздо чаще у вас будет одна директория source для .java файлов, но много директорий для классов или JAR-архивов, где расположены прекомпилированные библиотеки сторонних производителей. Такова роль classpath.

#### Установка classpath <a id="N10171"></a>

В средних и больших проектах перекомпилирование каждого файла каждый раз может занимать очень много времени. Вы можете облегчить нагрузку, отдельно компилируя и храня независимые части одного и того же проекта в разных классах или директориях bin. Эти директории добавляются к classpath.

Есть несколько способов добавить класс к classpath. Переключатель командной строки `-classpath`, тем не менее, - единственное, что следует использовать. Например, предположим, что я хочу импортировать файлы из другого проекта, который я до этого скомпилировал в директорию /home/ninja/classes. Затем я бы добавил `-classpath /home/ninja/classes` к командной строке следующим образом:

```text
javac -d bin -sourcepath src -classpath /home/ninja/classes /src/com/ninja/task/Solution.java
```

Две и более директорий разделяются двоеточиями. 

> **Директории верхнего уровня**   
> Обратите внимание, что директории, которые я указываю здесь, все являются директориями верхнего уровня, которые содержат иерархию, подобную com/ninja/foo/bar or nu/xom/util. Директории, имена которых соответствуют именам пакета \(com, ninja, math, etc.\) никогда не включаются прямо в sourcepath или classpath.

До сих пор я предполагал, что программа не использует никакие отдельно скомпилированные библиотеки сторонних производителей. Но если она использует их, вам нужно их также добавить к classpath. Библиотеки обычно размещаются как JAR-файлы, например junit.jar или icu4j.jar. В этом случае вы добавляете именно JAR-файл к classpath, а не директорию, которая содержит его. \(По существу, JAR-файл действует как директория, которая содержит скомпилированные .class-файлы.\) JAR-файлы используются только для .class-файлов и classpath, а не для .java-файлов и sourcepath.

### Запуск программы <a id="N1019E"></a>

Во время запуска программы нужно определить только две вещи:

* classpath.
* Полностью классифицированное для пакета имя класса, которое содержит `main()` method.

Вам не нужно указывать sourcepath.

Обычно classpath - это тот же самый classpath, который вы использовали, чтобы скомпилировать программу, с добавлением директории, куда был размещен скомпилированный вывод. Например, если команда компилирования была следующей:

```text
$ javac -d bin -sourcepath src -classpath /home/ninja/classes:/home/ninja/lib/junit.jar  src/com/ninja/task/Solution.java
```

и метод `main()` был в классе `com.ninja.task.Solution`, тогда вы будете запускать программу следующим образом:

```text
java -classpath bin:/home/ninja/classes:/home/ninja/lib/junit.jar com.ninja.task.Solution
```

Обратите особое внимание, что последний элемент командной строки - это _имя класса_. Это не имя файла. Оно не заканчивается на .java или .class. Этот класс должен быть найден где-нибудь в classpath.

### Другие места, где располагаются классы <a id="N101C5"></a>

Я настоятельно рекомендую вам точно указывать classpath, когда вы компилируете и когда запускаете программу. Есть другие места, куда вы можете помещать файлы так, что они добавляются к classpath и обнаруживаются и компилятором javac и интерпретатором java. Эти опции экономят лишь немного набора текста, и они делают это за счет большого количества отлаживания, когда - а не если - вы случайно располагаете старую версию класса в classpath.

В этом разделе я покажу вам некоторые места, где вы можете найти прячущиеся классы, которые неожиданно появляются в вашем classpath и вызывают проблемы. Это наиболее вероятно может произойти на машинах, которые вы не контролируете, например на сервере.

#### Текущая рабочая директория <a id="N101CD"></a>

Компилятор всегда добавляет текущую рабочую директорию \(.\) к classpath, запрашиваете вы это явно или нет. Очень легко забыть, что находится или не находится в той же директории, где и вы. Таким образом, попытайтесь избежать размещения любых классов или иерархий в ваш проект или начальную директорию. Вместо этого всегда храните вещи аккуратно разделенными на src-директории для .java-файлов и директории bin для .class-файлов.

#### CLASSPATH <a id="N101D3"></a>

Через некоторое время вы можете устать от ручного добавления директорий bin и JAR-архивов к classpath. Тогда вы можете открыть для себя переменную среды `classpath`. Вы можете добавить директории и JAR-архивы к переменной среды `classpath` только один раз. Затем вам не придется набирать их пути каждый раз, когда вы запускаете javac или java.

Сопротивляйтесь соблазну. Это только вызовет новые проблемы, если вы загрузите неверный класс или неверную версию класса. Любое время, которое вы сэкономите на наборе текста, будет отнято у вас отладкой проблем, вызванных случайной загрузкой неверных классов, и оно будет в сотни раз больше. Есть более надежные способы автоматизировать classpath и избежать набора текста.

#### jre/lib/ext <a id="N101E1"></a>

JAR-архивы, расположенные в вашей jre/lib/ext директории, добавляются к classpath всех приложений, запущенных на данной виртуальной машине. Хотя это кажется удобным, эта ошибка даст о себе знать позже, она сродни добавлению директорий к переменной среды `classpath`. Рано или поздно \(возможно рано\), вы загрузите неверную версию класса из места, о котором вы даже и не думаете, и потеряете много времени на отладку.

Эта проблема особенно серьезна во время использования серверных приложений. Убедитесь, что сервер, который вы используете, не имеет никаких дополнительных JAR'ов в своей директории jre/lib/ext. Проблемы, вызванные неверной версией JAR-архива в classpath может быть чрезвычайно трудно устранить, если вы не распознаете признаки или не знаете, что конкретно искать. Чтобы избежать этих проблем, некоторые среды разработки зашли настолько далеко, что пишут свои собственные программы загрузки классов, которые обходят обычные загрузочные механизмы кода Java.

#### jre/lib/endorsed <a id="N101EC"></a>

JAR-файлы в директории jre/lib/endorsed также добавляются к classpath всех приложений, запущенных на данной виртуальной машине. Разница заключается в том, что эти файлы на самом деле добавляются скорее к _bootclasspath_, чем обычному classpath, и могут замещать стандартные классы, поставляющиеся с JDK. Этот подход особенно полезен для модернизации XML-анализатора и устранения ошибок в виртуальной машине.

Еще раз повторю, что хотя этот способ кажется удобным, это долговременная ошибка по той же самой причине. Если вам нужно переместить классы JDK, используйте опцию `-Xbootclasspath/p` во время запуска, чтобы избежать случайной загрузки неверной версии класса.

### В заключение <a id="N10229"></a>

Даже такую непростую проблему как classpath, вы можете решить, используя несколько простых правил. В частности:

* Располагайте каждый класс в пакете.
* Точно следуйте стандартам называния пакета и класса и правилам использования прописных букв.
* Убедитесь, что иерархия вашего пакета соответствует иерархии директории.
* Всегда используйте опцию `-d` для javac.
* Никогда ничего не помещайте в jre/lib/ext.
* Никогда ничего не помещайте в jre/lib/endorsed.
* Никогда не помещайте .java-файлы в ту же самую директорию, что и .class-файлы.
* Никогда не помещайте никакие .java или .class-файлы в текущую рабочую директорию.

Один последний совет: много проблем с classpath, требующих большого расхода времени, вращаются вокруг простых ошибок, таких как неправильное написание имени директории или компилирование из неверной директории. Если вы не можете определить, что идет не так, попросите друга или коллегу взглянуть на вашу проблему. Часто я обнаруживаю, что нахожусь слишком близко к ошибке, чтобы её увидеть, а для кого-то ещё она сразу же очевидна. Еще одна пара глаз - это эффективный метод устранения ошибок.

Classpath не легок, но он управляем, и есть способ справиться с его сумасшествием. Немного осторожности и внимания к заданию имён, аргументам командной строки, и структуре директорий должны помочь вам скомпилировать и запустить программы с минимальными трудностями.















